package andyp.gpo746

/*
 * For the compile time calculations see:
 * ./src/buildSrc/src/main/kotlin/gpo746/Ch340gConstants.kt
 *
 * For want of ANY official documentation at all, this has been cargo-culted
 * from various sources.
 *
 * Android USB host serial driver library.
 * https://github.com/mik3y/usb-serial-for-android
 *
 * Usb serial controller for Android
 * https://github.com/felHR85/UsbSerial
 *
 * The FreeBSD CH341/340 Driver
 * https://github.com/freebsd/freebsd-src/blob/master/sys/dev/usb/serial/uchcom.c
 *
 * The NetBSD CH341/340 Driver
 * http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/sys/dev/usb/uchcom.c
 *
 * The Linux CH341 Driver
 * https://github.com/torvalds/linux/blob/master/drivers/usb/serial/ch341.c
 */

enum class ReadRequest(val code: UByte) {
    VendorGetVersion(0x5Fu),
    VendorReadRegisters(0x95u)
}

enum class WriteRequest(val code: UByte) {
    VendorWriteRegisters(0x9Au),
    VendorSerialInit(0xA1u),
    VendorModemControl(0xA4u)
}

enum class ReadRegister(val address: UShort) {
    GCL(0x0706u)
}

enum class WriteRegister(val address: UShort) {
    BaudDivisorPreScale(0x1312u),
    BaudMod(0x0F14u),
    LCR(0x2518u),
    GCL(0x0606u)
}

enum class GclOutputBit(val mask: UByte) {
    DTR(0x20u), // 1 << 5
    RTS(0x40u) //  1 << 6
}

enum class GclInputBit(val mask: UByte) {
    CTS(0x01u),
    DSR(0x02u),
    RI(0x04u),
    DCD(0x08u)
}

@Suppress("MagicNumber")
abstract class UsbResultBuffer {
    @OptIn(kotlin.ExperimentalUnsignedTypes::class)
    protected fun shortFromBuffer(buffer: ByteArray?): UShort {
        if (buffer == null) {
            return 0u
        } else {
            val lowByte = buffer[1].toUInt() and 0xFFu
            val highByte = buffer[0].toUInt() and 0xFFu
            return ((lowByte shl 8) or highByte).toUShort()
        }
    }
}

@OptIn(kotlin.ExperimentalUnsignedTypes::class)
class Ch340g(usbSystem: UsbSystemInterface) : UsbResultBuffer() {

    private val usb = usbSystem

    private fun write(request: WriteRequest, value: UShort) {
        usb.write(request.code, value, 0u)
    }

    private fun writeRegisters(register: WriteRegister, value: UShort) {
        usb.write(WriteRequest.VendorWriteRegisters.code, register.address, value)
    }

    private fun read(request: ReadRequest): UShort {
        return shortFromBuffer(
            usb.read(
                request.code,
                0u
            )
        )
    }

    // // // // // // // // // // // // // // // // // // // // // // // // //

    public fun start() {
        val version: UShort = read(ReadRequest.VendorGetVersion)
        if (version != @usedChipVersion@.toUShort()) {
            throw Exception("version should be @usedChipVersion@, but it's $version")
        }
        write(WriteRequest.VendorSerialInit, 0u)
        writeRegisters(WriteRegister.BaudDivisorPreScale, @divisorPrescale@)
        writeRegisters(WriteRegister.BaudMod, @mod@)
        writeRegisters(WriteRegister.LCR, @defaultLcr@)
    }

    public fun readSerial(): String {
        return usb.bulkRead().decodeToString().substringBefore('\u0000')
    }

    public fun writeHandshake(handshakeOutputRTS: Boolean) {
        // DTR isn't in use so it's bit is always set "off"
        var modemControl: UByte = if (handshakeOutputRTS) GclOutputBit.RTS.mask else 0u
        write(WriteRequest.VendorModemControl, modemControl.toUShort())
    }

    public fun readHandshake(): Boolean {
        val modemControl: UShort = shortFromBuffer(
            usb.read(
                ReadRequest.VendorReadRegisters.code,
                ReadRegister.GCL.address
            )
        )
        val mask = GclInputBit.RI.mask.toUShort()
        return (modemControl and mask) == mask
    }
}
