package gpo_746

/*
 * For the compile time calculations see:
 * ./src/buildSrc/src/main/kotlin/gpo_746/Ch340gConstants.kt
 *
 * For want of ANY official documentation at all, this has been cargo-culted
 * from various sources.
 *
 * Android USB host serial driver library.
 * https://github.com/mik3y/usb-serial-for-android
 *
 * Usb serial controller for Android
 * https://github.com/felHR85/UsbSerial
 *
 * The FreeBSD CH341/340 Driver
 * https://github.com/freebsd/freebsd-src/blob/master/sys/dev/usb/serial/uchcom.c
 *
 * The NetBSD CH341/340 Driver
 * http://cvsweb.netbsd.org/bsdweb.cgi/~checkout~/src/sys/dev/usb/uchcom.c
 *
 * The Linux CH341 Driver
 * https://github.com/torvalds/linux/blob/master/drivers/usb/serial/ch341.c
 */

enum class ReadRequest(val code: UByte) {
    vendorGetVersion(0x5Fu),
    vendorReadRegisters(0x95u)
}

enum class WriteRequest(val code: UByte) {
    vendorWriteRegisters(0x9Au),
    vendorSerialInit(0xA1u),
    vendorModemControl(0xA4u)
}

enum class ReadRegister(val address: UShort) {
    // When NetBSD reads GCL, it only uses gcl1Low - the first byte
    // When mik3y reads GCL, it only returns the first byte from the buffer
    // When felHR85 reads GCL, it only uses the first byte
    gcl(0x0706u)
}

enum class WriteRegister(val address: UShort) {
    baudDivisorPrescale(0x1312u),
    baudMod(0x0F14u),
    lcr(0x2518u),
    // Only NetBSD writes GCL at all - it writes the same value to gcl1Low twice
    gcl(0x0606u)
}

enum class GclOutputBit(val mask: UByte) {
    DTR(0x20u), // 1 << 5
    RTS(0x40u)  // 1 << 6
}

enum class GclInputBit(val mask: UByte)  {
    CTS(0x01u),
    DSR(0x02u),
    RI(0x04u),
    DCD(0x08u)
}

abstract class UsbResultBuffer {
    @OptIn(kotlin.ExperimentalUnsignedTypes::class)
    protected fun shortFromBuffer(buffer: ByteArray): UShort {
        return (
            ((buffer[1].toUInt() and 0xFFu) shl 8) or
            (buffer[0].toUInt() and 0xFFu)
        ).toUShort()
    }
}

@OptIn(kotlin.ExperimentalUnsignedTypes::class)
class Ch340g(usbSystem: UsbSystemInterface): UsbResultBuffer() {

    private val usb = usbSystem

    private fun write(request: WriteRequest, value: UShort) {
        usb.write(request.code, value, 0u)
    }

    private fun writeRegisters(register: WriteRegister, value: UShort) {
        usb.write(WriteRequest.vendorWriteRegisters.code, register.address, value)
    }

    private fun read(request: ReadRequest): UShort {
        return shortFromBuffer(usb.read(
            request.code,
            0u
        ))
    }

    private fun readRegisters(register: ReadRegister): UShort {
        return shortFromBuffer(usb.read(
            ReadRequest.vendorReadRegisters.code,
            register.address
        ))
    }

    private fun initialise() {
        val version: UShort = read(ReadRequest.vendorGetVersion)
        if (version != @usedChipVersion@.toUShort()) {
            throw Exception("version should be @usedChipVersion@, but it's ${version}")
        }
        write(WriteRequest.vendorSerialInit, 0u)
        writeRegisters(WriteRegister.baudDivisorPrescale, @divisorPrescale@)
        writeRegisters(WriteRegister.baudMod, @mod@)
        writeRegisters(WriteRegister.lcr, @defaultLcr@)
    }

    ////////////////////////////////////////////////////////////////////////////

    public fun start() {
        val timeoutMilliseconds = 10
        usb.start(0x1A86u, 0x7523u, timeoutMilliseconds)
        initialise()
    }

    public fun finish() {
        usb.finish()
    }

    public fun readSerial(): String {
        return usb.bulkRead().decodeToString().substringBefore('\u0000')
    }

    public fun writeHandshake(handshakeOutputRTS: Boolean) {
        var modemControl: UByte = if (handshakeOutputRTS) GclOutputBit.RTS.mask else 0u
        write(WriteRequest.vendorModemControl, modemControl.toUShort())
    }

    public fun readHandshake(): Boolean {
        val modemControl = readRegisters(ReadRegister.gcl)
        val mask = GclInputBit.RI.mask.toUShort()
        return (modemControl and mask) == mask
    }
}
